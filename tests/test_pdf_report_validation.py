"""
Tests for PDF report validation checklist (3 pages, footer, audit trail coverage).

Ensures that the report generated by `app.pdf_generator.generate_transfer_report`
complies with the professional formatting described in the state.md checklist.
"""

from datetime import datetime, timedelta, timezone

import pytest

from app.utils.pdf_generator import generate_transfer_report
from app.models import (
    Transfer,
    Checksum,
    AuditLog,
    TransferStatus,
    ChecksumType,
    AuditEventType,
)


def _create_sample_transfer() -> Transfer:
    """Builds a completed transfer with realistic timestamps for reporting."""
    now = datetime.now(timezone.utc)
    transfer = Transfer(
        id=42,
        source_path="/tmp/source/file.bin",
        destination_path="/tmp/dest/file.bin",
        file_size=1024 * 1024,
        file_name="file.bin",
        status=TransferStatus.COMPLETED,
        bytes_transferred=1024 * 1024,
        progress_percent=100,
        started_at=now - timedelta(seconds=120),
        completed_at=now,
        updated_at=now,
        created_at=now - timedelta(seconds=180),
        operation_mode="copy",
    )
    return transfer


def _create_checksum_records(transfer_id: int) -> list[Checksum]:
    """Create the triple SHA-256 checksum records needed for the report."""
    base_hash = "a" * 64
    return [
        Checksum(
            id=1,
            transfer_id=transfer_id,
            checksum_type=ChecksumType.SOURCE,
            checksum_value=base_hash,
            calculated_at=datetime.now(timezone.utc),
        ),
        Checksum(
            id=2,
            transfer_id=transfer_id,
            checksum_type=ChecksumType.DESTINATION,
            checksum_value=base_hash,
            calculated_at=datetime.now(timezone.utc),
        ),
        Checksum(
            id=3,
            transfer_id=transfer_id,
            checksum_type=ChecksumType.FINAL,
            checksum_value=base_hash,
            calculated_at=datetime.now(timezone.utc),
        ),
    ]


def _create_audit_logs(transfer_id: int) -> list[AuditLog]:
    """Create a few audit events to populate the Audit Trail section."""
    now = datetime.now(timezone.utc)
    return [
        AuditLog(
            id=101,
            transfer_id=transfer_id,
            event_type=AuditEventType.TRANSFER_CREATED,
            message="Transfer initiated for PDF validation",
            created_at=now - timedelta(seconds=170),
        ),
        AuditLog(
            id=102,
            transfer_id=transfer_id,
            event_type=AuditEventType.CHECKSUM_CALCULATED,
            message="Triple SHA-256 earned",
            created_at=now - timedelta(seconds=90),
        ),
        AuditLog(
            id=103,
            transfer_id=transfer_id,
            event_type=AuditEventType.TRANSFER_COMPLETED,
            message="Transfer finished successfully",
            created_at=now,
        ),
    ]


@pytest.fixture
def pdf_content() -> bytes:
    """Returns the binary content of the generated PDF."""
    transfer = _create_sample_transfer()
    checksums = _create_checksum_records(transfer.id)
    audit_logs = _create_audit_logs(transfer.id)

    pdf_buffer = generate_transfer_report(transfer, checksums, audit_logs)
    return pdf_buffer.getvalue()


def test_pdf_is_landscape_three_pages(pdf_content: bytes) -> None:
    """Checks that the PDF has at least three pages (executive, technical, audit)."""
    page_markers = pdf_content.count(b"/Type /Page")
    assert page_markers >= 3, "Expected at least three pages in the PDF report"


def test_pdf_buffer_has_content(pdf_content: bytes) -> None:
    """Verifies the PDF buffer is not empty and contains a typical PDF header."""
    assert pdf_content.startswith(b"%PDF-1.4")
    assert len(pdf_content) > 2000, "PDF report appears too small to include all sections"


def test_pdf_responds_to_extra_audit_logs() -> None:
    """Ensures that adding audit log entries grows the PDF (proof audit trail is rendered)."""
    transfer = _create_sample_transfer()
    checksums = _create_checksum_records(transfer.id)
    basic_logs = _create_audit_logs(transfer.id)
    extended_logs = basic_logs + [
        AuditLog(
            id=200 + idx,
            transfer_id=transfer.id,
            event_type=AuditEventType.CHECKSUM_VERIFIED,
            message=f"Extra audit row {idx}",
            created_at=datetime.now(timezone.utc) + timedelta(seconds=idx),
        )
        for idx in range(5)
    ]

    minimalist_pdf = generate_transfer_report(transfer, checksums, basic_logs).getvalue()
    extended_pdf = generate_transfer_report(transfer, checksums, extended_logs).getvalue()

    assert len(extended_pdf) > len(minimalist_pdf), "PDF should grow when more audit events exist"
